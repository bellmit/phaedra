package eu.openanalytics.phaedra.link.importer;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.core.runtime.jobs.Job;

import eu.openanalytics.phaedra.base.console.ConsoleManager;
import eu.openanalytics.phaedra.base.util.misc.NumberUtils;
import eu.openanalytics.phaedra.datacapture.DataCaptureService;
import eu.openanalytics.phaedra.datacapture.DataCaptureTask;
import eu.openanalytics.phaedra.datacapture.model.PlateReading;
import eu.openanalytics.phaedra.link.data.DataLinkService;
import eu.openanalytics.phaedra.link.data.DataLinkTask;
import eu.openanalytics.phaedra.model.plate.PlateService;
import eu.openanalytics.phaedra.model.plate.vo.Plate;

public class ImportJob extends Job {

	private ImportTask task;

	public ImportJob(ImportTask task) {
		super("Import" + (task.sourcePath == null ? "" : ": " + task.sourcePath));
		this.task = task;
	}

	@Override
	public boolean belongsTo(Object family) {
		if (family != null && family.equals("ImportJobFamily"))
			return true;
		return false;
	}

	@Override
	protected IStatus run(IProgressMonitor monitor) {

		if (monitor.isCanceled()) return doCancel();

		try {
			monitor.beginTask("Importing", 100);

			// Step 1: Capture data
			// ********************

			monitor.subTask("Capturing data from " + task.sourcePath);
			SubProgressMonitor subMonitor = new SubProgressMonitor(monitor, 75);

			DataCaptureTask captureTask = createCaptureTask();
			List<PlateReading> readings = DataCaptureService.getInstance().executeTask(captureTask, subMonitor);

			if (captureTask.isTest() || monitor.isCanceled()) return doCancel();

			if (readings.isEmpty()) {
				// Nothing was captured: abort the import job.
				ConsoleManager.getInstance().print("INFO: Import aborted: no readings found.");
				return doCancel();
			}

			// Step 2: Map readings with plates
			// ********************************

			Map<PlateReading, Plate> plateMapping = new HashMap<PlateReading, Plate>();

			if (task.createNewPlates) {
				monitor.subTask("Creating new plates in " + task.targetExperiment);
				int sequence = 1;
				for (PlateReading reading: readings) {
					Plate newPlate = createPlate(reading, sequence++);
					plateMapping.put(reading, newPlate);
				}
			} else {
				// Use the plateMapping generated by the mapper page.
				// Replace the temporary reading objects with the parsed readings.
				for (PlateReading tempReading: task.plateMapping.keySet()) {
					for (PlateReading reading: readings) {
						// Note: contains() instead of equals() because some modules customize the sourcePath
						// into a subfolder, and the tempReading is not aware of this.
						if (reading.getSourcePath().contains(tempReading.getSourcePath())
								&& tempReading.getBarcode().equals(reading.getBarcode())) 
						{
							// get the plate that is mapped to the this reading
							Plate mappedPlate = task.plateMapping.get(tempReading);
							
							// set the format of the existing plate to the reading 
							//(only well data import modules read in the plate format, but a well data import module might
							// not be executed during the import)
							if(reading.getColumns()==0)
								reading.setColumns(mappedPlate.getColumns());
							if(reading.getRows()==0)
								reading.setRows(mappedPlate.getRows());
	
							plateMapping.put(reading, mappedPlate);

						}
					}
				}
			}

			if (monitor.isCanceled()) 
				return doCancel();

			// Step 3: Link readings with plates
			// *********************************

			monitor.subTask("Linking plate data");
			subMonitor = new SubProgressMonitor(monitor, 20);

			DataLinkTask linkTask = DataLinkService.getInstance().createTask();
			linkTask.createNewPlates = false;
			linkTask.targetExperiment = task.targetExperiment;
			linkTask.mappedReadings = plateMapping;
			linkTask.linkPlateData = task.importPlateData;
			linkTask.linkWellData = task.importWellData;
			linkTask.linkSubWellData = task.importSubWellData;
			linkTask.linkImageData = task.importImageData;

			IStatus linkOutcome = DataLinkService.getInstance().executeTask(linkTask, subMonitor);

			if (linkOutcome.getSeverity() == IStatus.ERROR) {
				return linkOutcome;
			} else if (linkOutcome.getSeverity() == IStatus.CANCEL) {
				return doCancel();
			}

			subMonitor.done();
			if (monitor.isCanceled()) return doCancel();

			// Step 4: (Optional) Link plates with definitions
			// ***********************************************

			if (task.linkBarcodes) {
				monitor.subTask("Linking plate definitions with " + task.linkSourceId);
				//TODO Implement barcode linking
				throw new UnsupportedOperationException("Barcode linking at import-time is not supported.");
			}
			monitor.worked(5);

			if (monitor.isCanceled()) return doCancel();

			monitor.done();

		} catch (Throwable e) {
			return doError(e);
		}

		return Status.OK_STATUS;
	}

	private DataCaptureTask createCaptureTask() {

		DataCaptureTask captureTask = DataCaptureService.getInstance().createTask(task.sourcePath, task.getCaptureConfigId());
		
		// Pass all import parameters as capture parameters, for the modules who might need it.
		captureTask.getParameters().putAll(task.getParameters());
		captureTask.setTest(task.getParameters().get(DataCaptureTask.PARAM_TEST) == Boolean.TRUE);
		
		// Set these parameters for completeness (they are saved in the PlateReading object).
		if (captureTask.getParameters().get(DataCaptureTask.PARAM_EXPERIMENT_NAME) == null) {
			captureTask.getParameters().put(DataCaptureTask.PARAM_EXPERIMENT_NAME, task.targetExperiment.getName());
		}
		if (captureTask.getParameters().get(DataCaptureTask.PARAM_PROTOCOL_NAME) == null) {
			captureTask.getParameters().put(DataCaptureTask.PARAM_PROTOCOL_NAME, task.targetExperiment.getProtocol().getName());
		}
		
		// Set this parameter for validation in the image compression module.
		captureTask.getParameters().put("experiment", task.targetExperiment);
		
		if (captureTask.getConfigId() == null) {
			throw new RuntimeException("No capture configuration found for protocol " + task.targetExperiment.getProtocol().getName());
		}

		String[] filter = ImportUtils.createFilter(
				task.getCaptureConfigId(),
				task.importWellData,
				task.importSubWellData,
				task.importImageData);
		captureTask.setModuleFilter(filter);

		return captureTask;
	}

	private Plate createPlate(PlateReading reading, int sequence) {
		int rows = reading.getRows();
		int cols = reading.getColumns();
		
		if (reading.getFileInfo() != null && NumberUtils.isNumeric(reading.getFileInfo())) {
			sequence = Integer.parseInt(reading.getFileInfo());
		}
		
		Plate plate = PlateService.getInstance().createPlate(task.targetExperiment, rows, cols);
		plate.setSequence(sequence);
		plate.setBarcode(reading.getBarcode());

		PlateService.getInstance().updatePlate(plate);

		return plate;
	}
	
	private IStatus doCancel() {
		return Status.CANCEL_STATUS;
	}

	private IStatus doError(Throwable e) {
		return new Status(IStatus.ERROR, Activator.getDefault().getBundle().getSymbolicName(), e.getMessage(),
				e.getCause());
	}
}
